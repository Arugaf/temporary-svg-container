# Блокчейн и DApp

> Разработка децентрализованных приложений (DApp) на основе блокчейна с использованием фреймворка **Substrate**.

## Содержание

1. [Введение](#введение)
2. [Про блокчейн и децентрализованные приложения](#про-блокчейн-и-децентрализованные-приложения)
3. [О фреймворке и языке](#о-фреймворке-и-языке)
	1. [Введение в Substrate](#введение-в-substrate)
	2. [Язык Rust](#язык-rust)
4. [Настройка окружения](#настройка-окружения)
	1. [Docker](#docker)
	2. [Substrate](#substrate)
5. [Создание простого децентрализованного приложения](#создание-простого-децентрализованного-приложения)
6. [Развертывание собственной блокчейн сети](#развертывание-собственной-блокчейн-сети)
7. [Задание](#задание) <---
8. [Полезные ссылки](#полезные-ссылки)

## Введение

В данной лабораторной работе рассматриваются основы создания децентрализованных приложений и приватных блокчейн-сетей

Изучаются базовые понятия (блокчейн, транзакции, консенсус, DApp) и методы работы с данными в блокчейнах.

По итогу предлагается создать собственное децентрализованное приложение, реализующее концепцию **PoA**, поднять для него сеть узлов, а также написать фронтенд для взаимодействия с пользователями получившегося DApp.

## Про блокчейн и децентрализованные приложения

> Скачивание необходимых инструментов, и компиляция шаблонов может занять какое-то время, поэтому сначала стоит [настроить окружение](#настройка-окружения).

**Блокчейн** - технология, в основе своей представляющая цепочку (*engl.* chain) блоков, содержащих некие данные, и связанных между собой тем, что каждый последующий блок содержит хеш предыдущего. <- запятая лишняя

Одной из ключевых особенностей блокчейна является значительная трудоемкость попытки изменить его состояние путем изменения уже существующего блока, т.к. это повлечет за собой цепочку изменений с необходимостью заново вычислить все последующие блоки. В сочетании с алгоритмами консенсуса это обеспечивает почти полную гарантию перманентности записанных данных. 

Блокчейн является основой множества децентрализованных приложений, работающих, как правило, на основе **peer-to-peer сети**. Новые узлы могут свободно подключаться к этой сети и сразу начинают генерировать (майнить) новые блоки с информацией.

Т.к. узлов много, то они могут генерировать множество разных блоков, содержащих одинаковые или различные транзакции. **Транзакция** определяет какую-то полезную нагрузку (информацию), добавляющуюся в блокчейн. Это может быть информация о покупке какого-то объекта, о передаче или начислении некой валюты, записью об изменении состояния и т.п.

Из-за того, что блоки могут быть разными, блокчейн представляет собой не просто связный список, а **DAG** - Directed Acyclic Graph (направленный ациклический граф). Консистентность состояния блокчейна между различными узлами достигается с помощью **алгоритмов консенсуса**. Эти алгоритмы обеспечивают и гарантируют существование единственной основной цепочки блоков на всех узлах конкретной сети.

Для уменьшения нагрузки на блокчейн-сеть и увеличения ее безопасности, а также других причин (которые зависят от конкретной цели применения блокчейна), майнинг каждого нового блока сопровождается выполнением какой-то работы или иными затратами реальных физических ресурсов. Это позволит обеспечить определенный уровень защиты сети от атак с целью изменения состояния блокчейна или попытки нагрузить ее множеством некорректных данных.

Как правило современные блокчейны используют алгоритмы консенсунса из классов **Proof of Stake** (PoS, доказательство владения) и **Proof of Work** (PoW, доказательство выполнения работы). Ethereum, Bitcoin, Polkadot и многие другие крупные сети используют алгоритмы консенсуса, основанные именно на этих классах. Помимо этого также существуют классы **Proof of Space**, **Proof of Authority** и др.

Блокчейн хорошо подходит не только для создания систем и приложений, предусматривающих открытое взаимодействие между пользователями с равными полномочиями (криптовалюты, биржи, финансовые приложения, блокчейны блокчейнов и т.д.), но и для систем, предусматривающих некоторую регуляцию с разделением прав (голосования, системы электронной документации, различные реестры и пр.), а также для систем смешанных типов (например, игры с использованием **NFT** и системы хранения данных).

Последние два типа систем подразумевают наличие частных сетей, которые развертываются самостоятельно. Состояние блокчейна в таких системах может полностью или частично контролироваться отдельными лицами, вплоть до полной замены основной цепочки и управлением генерацией новых блоков. Такие системы могут в принципе работать без применения PoW или PoS.

Приложения, работающие на основе блокчейна, называющиеся **DApp** (децентрализованные приложения), обычно создаются на базе существующих фреймворков и сетей. Ethereum, например, позволяет создавать такие приложения с использованием **смарт-контрактов**, работающих прямо на блокчейне этой сети. Пользователи через транзакции могут взаимодействовать с таким смарт-контрактом, в котором заранее прописаны некоторые условия, функции и изменяемое состояние.

В данной лабораторной работе, однако, будет рассматриваться создание собственного DApp не с использованием смарт-контрактов, а через создание собственного блокчейна. Ключевое отличие таких приложений от основанных на смарт-контрактах в том, что последние подразумевают использование уже функционирующей сети и не могут изменять ее поведение. Тогда как создание собственного блокчейна позволяет более гибко настраивать взаимодействие с ним.

## О фреймворке и языке

### Введение в Substrate

**[Substrate](https://substrate.io/)** - фреймворк для создания собственных блокчейнов общего назначения. Substrate использует Rust в качестве языка программирования и может компилироваться (предпочтительно) в WebAssembly.

#### Архитектура

Архитектура DApp на основе Substrate выглядит следующим образом:

![Архитектура узла](https://docs.substrate.io/static/262e7fe9f1f7d3db5dd8cee450d77c86/c1b63/substrate-arch.png)

 - **Storage** - обеспечивает хранение некой значимой информации на блокчейне. Имеется множество хранилищ, часть из которых определяется разработчиком, и которые хранят разные данные, необходимые для работы приложения. В частности, Wasm бинарник, обеспечивающий работу каждого отдельного узла, тоже хранится на блокчейне. **FRAME** (*прим.* будет рассказано ниже) предоставляет следующие **типажи** для storage:
	 - одиночное значение (как переменная);
	 - key-value хранилище (map);
	 - double-map (два ключа и одно значение);
	 - N-map (N ключей и одно значение);

- **Runtime** - определяет логику работы децентрализованного приложения, в частности, правила генерации новых блоков с транзакциями. Хранится на блокчейне, что позволяет произвести **forkless upgrade** - обновление узлов во всей сети без прекращения ее работы.

- **P2P-сеть** - возможность работы блокчейн-сети по одноранговой сети с помощью [libp2p](https://libp2p.io/).

- **Consensus** - алгоритмы, позволяющие добиться  **консенсуса** (согласия) о состоянии блокчейна внутри сети для всех узлов.

- **RPC** - Remote Procedure Call, позволяет взаимодействовать с децентрализованным приложением. Обеспечивается нативная поддержка [React](https://en.reactjs.org/).

- **Telemetry** - различные метрики, доступ к которым осуществляется через [Prometheus](https://prometheus.io/).

#### Разработка DApp

**FRAME** - Framework for Runtime Aggregation of Modularized Entities, набор различных модулей и библиотек. Подобные модули называются pallets (паллеты) и содержат некоторую логику (например, какие-то паллеты определяют алгоритм консенсуса, другие добавляют валюту и т.д.).

![FRAME](https://docs.substrate.io/static/3499b4465d746bd0dcb22e34779d5546/c1b63/frame-arch.png)

**Dispatchables** - функции, которые могут быть вызваны за пределами системы (например, пользователем) и изменяющие ее состояние.

**Config** - описывает набор различных типов и параметров паллета.

**Events** - каждый модуль (паллет) может генерировать различные сообщения (события) при выполнении каких-то условий. События задаются разработчиком и оповещают внешние объекты (пользователей, приложения и др.) о том, что что-то произошло, передавая при этом какие-то данные.

**Обработка ошибок** -  рантайм код **никогда** (!) не должен выбрасывать исключение (panic в терминах Rust). При использовании FRAME в Substrate, вызываемые интерфейсные функции (dispatchables) должны возвращать особый [тип](https://docs.substrate.io/rustdocs/latest/frame_support/dispatch/type.DispatchResult.html), который может [указывать](https://docs.substrate.io/rustdocs/latest/frame_support/dispatch/enum.DispatchError.html) на то, что в ходе выполнения функции произошла ошибка.

### Язык Rust

Для написания децентрализованных приложений с использованием фреймворка Substrate, используется язык Rust.

[**Rust**](https://www.rust-lang.org/) - мультипарадигмальный компилируемый язык со строгой статической типизацией, сочетающие парадигмы функционального и процедурного программирования с объектной системой, основанной на **типажах** (трейтах, *engl.* traits).

Rust синтаксически близок к си-подобным языкам программирования, но обладает своей собственной специфической моделью памяти, основанной на механизмах **владения** (ownership) в соответствии с идиомой [RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) и **валидации ссылок**, которая реализовывается через понятие **времени жизни** (lifetime) и **анализатор заимствований** (borrow checker).

Данная модель позволяет избавиться от сборщика мусора. В совокупности все эти факторы делают Rust по скорости и функциональности сопоставимым с C++, но при этом язык **гарантирует** безопасную работу с памятью, так как возможные ошибки ловятся уже на стадии компиляции.

Rust поставляется с собственным менеджером пакетов и, одновременно, системой сборки - **Cargo**.

При использовании Rust в данной лабораторной работе, необходимо знать некоторые базовые вещи (более подробно с языком можно познакомиться по ссылкам: [en](https://doc.rust-lang.org/book/), [ru](https://doc.rust-lang.ru/book/), документацию можно посмотреть [здесь](https://doc.rust-lang.org/std/)).

- Переменные объявляются ключевым словом ``let``, поддерживается автоматическое выведение типа. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cfc15f2e6c45b413f4c8dfc60ba5083e).
	```rust
	fn type_of<T>(_: &T) -> &'static str {
	    std::any::type_name::<T>()
	}

	fn main() {
	    // тип выводится автоматически: i32 (целочисленное, 32 бита)
	    let x = 5; 
	    println!("{}", type_of(&x));
	    
	    // shadowing: можно заново объявить немьютабельную переменную с таким же именем (тип может быть любым)
	    // тип указывается явно: i64 (целочисленное, 64 бита)
	    let x: i64 = 6;
	    println!("{}", type_of(&x));
	    
	    // для констант тип надо указывать обязательно
	    // тип указывается явно: u32 (целочисленное беззнаковое, 32 бита)
	    const C: u32 = 10;
	    println!("{}", type_of(&C));
	}
	```

- Работа с ресурсами, которые хранит переменная, осуществляется в соответствии с мув-семантикой, согласно [аффинным типам](https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems). Если тип не реализует **трейт** ``Copy``, то владение ресурсом передается захватившей ее переменной (в том числе и при передаче переменных в функцию). Старая переменная при этом инвалидируется.
![Move semantics](https://raw.githubusercontent.com/Arugaf/temporary-svg-container/main/rust-move-copy-borrow-svg.svg)
	
	[``String``](https://doc.rust-lang.org/std/string/struct.String.html) - сложный тип, который не реализует трейт ``Copy``. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e8a494d31e7ec1a1014cc2bcae8cf13b).
	
	```rust
	fn main() {
	    // Сложный тип String, не реализующий трейт Copy
	    let x = String::from("x contains string");
	    println!("{}", x);
	    
	    let a = x;
	    println!("{}", a);
	    
	    // Ошибка компиляции, ресурс уже перемещен и им владеет переменная a
	    println!("{}", x);
	}
	```
	
	[``str``](https://doc.rust-lang.org/std/primitive.str.html) - примитивный тип (utf-8 слайс). [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9f3f84f3619a74d1a68a45412b7c01b2).
	
	```rust
	fn main() {
	    // Примитивный тип &str (ссылка), сам str на самом деле не реализует трейт Copy, но копируется область памяти
	    let x = "x contains string";
	    println!("{}", x);
	    
	    // Адреса a и x не совпадают, разные строки
	    let a = x;
	    println!("{}", a);
	    
	    println!("{}", x);
	}
	```

- Переменная по умолчанию немьютабельна (неизменяема, не путать с константами). Чтобы иметь возможность изменить значение переменной, необходимо использовать ключевое слово ``mut``.
	
	Переменную ``x`` нельзя поменять. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3e0a8906fb53800c46ff10b61af30f5b).
	 ```rust
	fn main() {
	    let x = 5;
	    println!("{}", x);
	    
	    // x - немьютабельная переменная, ошибка компиляции
	    x = 10;
	    println!("{}", x);
	}
	```
	Переменную ``x`` можно поменять. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2643a6cb585ebd66e69d67adcccee05e).
	```rust
	fn main() {
	    let mut x = 5;
	    println!("{}", x);
	    
	    x = 10;
	    println!("{}", x);
	}
	```

- В Rust можно передавать переменные по ссылке, которые всегда валидны (не могут ссылаться на неопределенную область памяти). Также доступны мьютабельные ссылки. При этом одновременно в одном скоупе (который и определяет время жизни (lifetime) переменной) может быть **только одна** мьютабельная ссылка на конкретный ресурс или же **много** немьютабельных ссылок (включая оригинальную переменную, владеющую ресурсом) .![Reference and mut reference](https://raw.githubusercontent.com/Arugaf/temporary-svg-container/main/rust-reference-mut.svg)  
	
	В этом примере кажется, что присутствует одновременно ссылка на запись и множество на чтение, но на деле компилятор может определить когда в последний раз использовалась переменная. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=39778b5a5920079446883577ef862532).
	```rust
	fn main() {
	    let mut a = 5;
	    let a_ref_1 = &a;
	    let a_ref_2 = &a;
	    
	    println!("{} {} {}", a, a_ref_1, a_ref_2);
	    
	    let a_ref_3 = &a;
	    println!("{}", a_ref_3);
	    
	    a = 10;
	    println!("{}", a);
	    
	    // если раскоментить, то будет ошибка компиляции
	    // println!("{}", a_ref_1);
	}
	```
	
	![enter image description here](https://raw.githubusercontent.com/Arugaf/temporary-svg-container/main/mutable-borrow.svg)
-	Функции объявляются ключевым словом ``fn``. Существует понятия **утверждение** (statement) и **выражение** (expression). Тело функции состоит из последовательности утверждений. В конце же может быть (опционально) выражение. Выражения также могут являться частью утверждения. Ключевое отличие выражений от утверждений в том, что последние не возвращают значения. Определение функции является утверждением, а ее вызов - выражением. Функции в Rust являются [объектами первого класса](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0), есть механизм замыканий. [Запустить код](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e07c552560345573536c1edba15ff828).
	```rust
	// функция принимает i32, выводит его и возвращает обратно
	fn foo(x: i32) -> i32 {
	    // содержит два утверждения
	    println!("foo was called: {}", x);
	    return x;
	}

	// функция не принимает параметров, возвращает два числа
	fn foo_two() -> (i32, u32) {
	    // выражение - отсутствует точка с запятой и ключевое слово return
	    (20, 40)
	}

	// функция принимает мьютабельную ссылку на число с плавающей запятой (64 бита) и функтор, 
	// принимающий два i32 и возвращающий два i32
	// функция ничего не возвращает, меняет значение полученной переменной и вызывает функтор
	fn foo_three(x: &mut f64, swap: fn(i32, i32) -> (i32, i32)) {
	    *x = 65.5;
	    
	    let lhs = 1;
	    let rhs = 2;
	    println!("lhs is {}, lhs is {}", lhs, rhs);
	    
	    let (lhs, rhs) = swap(lhs, rhs);
	    println!("lhs is {}, lhs is {}", lhs, rhs);
	}

	fn main() {
	    foo(1000);
	    
	    let (a, b) = foo_two();
	    println!("foo_two was called: {} {}", a, b);
	    
	    let mut float_num = 16.0;
	    println!("before foo_three: {}", float_num);
	    // в качестве второго аргумента передается анонимная функция
	    foo_three(&mut float_num, |l: i32, r: i32| -> (i32, i32) {(r, l)});
	    println!("after foo_three: {}", float_num);
	}
	```

- В Rust также есть поддержка [макросов](https://doc.rust-lang.org/book/ch19-06-macros.html?highlight=macros#macros) и система [**трейтов**](https://doc.rust-lang.org/book/ch10-02-traits.html) (типажей). Traits реализуют механизм обеспечения функциональности у типов, что в каком-то смысле делает их похожими на интерфейсы (абстрактные классов и т.п.) в других языках, но [не ограничивается](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html) этим (наиболее близкий аналог - концепты из C++20). 

Rust можно использовать с различными редакторами кода и IDE (ограниченно). Для VS Code есть [расширение](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer), обеспечивающее поддержку этого языка. Также есть отдельный [плагин](https://plugins.jetbrains.com/plugin/8182-rust) для CLion.

## Настройка окружения

Для выполнения лабораторной работы необходимо установить соответствующий тулчейн, необходимый для работы с фреймворком Substrate. 

> В общем и целом предполагается использование POSIX-совместимого окружения. Работа гарантируется только для Ubuntu 21.04+ + Chrome v100+.

### Docker

Можно использовать готовый образ, содержащий скомпилированные шаблоны. Весит довольно много.

Для простоты достаточно использовать Docker Desktop ([Windows](https://docs.docker.com/desktop/windows/install/), [Linux](https://docs.docker.com/desktop/linux/), [MacOS](https://docs.docker.com/desktop/mac/install/)).

Сами шаблоны внутри контейнера находятся в ``/opt/app`` в отдельных директориях (как если бы туда клонировали репозитории вручную). Наружу открыты порты 30330-30340 (для взаимодействия узлов сети между собой по p2p), 9944-9954 (ws порты), 9933-9943 (для RPC), 8000 (для фронтенд сервера). При желании можно открыть еще порты (например, для телеметрии) при запуске контейнера.

Отдельные узлы и фронтенд сервер предполагается запускать в разных контейнерах.

При запуске контейнера следует вручную указать volume, с указанием из какой директории (на текущей машине) в какую (в контейнере) будет отображаться файл с кодом (в образе нет заранее заданного volume). При первом запуске нужно скопировать (к сожалению) все из ``/opt/app`` в нужный volume. Сделать это можно следующей командой (займет какое-то время):
```bash
cp -a /opt/app/. /название-директории-в-контейнере/ 2> /dev/null
``` 

Это позволит сохранить прогресс в файловой системе и синхронизировать состояние между разными контейнерами (при условии, что для всех контейнеров всегда будут отображаться одна и та же директория в один и тот же volume).

Сам контейнер можно запустить так:
```bash
docker run \
-p 30333:30333 -p 9945:9945 -p 9933:9933 -p 8000:8000 \
-it -v полный-путь-к-директории-в-системе:полный-путь-к-директории-в-контейнере \
arugaf/blockchain-lab bash
```

Где на первой строчке через флаг ``-p`` указываются порты в системе:порты в контейнере (выбирать их нужно в зависимости от конфигурации узла, который будет запускаться в контейнере). Контейнер будет работать в интерактивном режиме, при этом можно будет изменять файлы, хранящиеся в указанной директории.

> При запуске контейнера в Windows может понадобиться добавить ``--privileged --security-opt="seccomp=unconfined"`` в параметры запуска.

### Substrate

Для выполнения лабораторной работы с использованием фреймворка Substrate необходимо установить Rust toolchain для работы с языком [Rust](https://www.rust-lang.org/) и скачать два репозитория с бойлерплейт-кодом: один для непосредственно блокчейн узла и второй для фронтенда (написанный с использованием React), через который можно будет напрямую взаимодействовать с блокчейном.

#### Linux

Debian/Ubuntu.

##### Git, Clang, LLVM, curl, Node, Yarn, необходимые библиотеки

1. Установить git, clang, curl, llvm, библиотеки ssl, udev.
	```bash
	sudo apt update && sudo apt install -y git clang curl libssl-dev llvm libudev-dev
	```
	
2. Проверить текущую версию Node.
	```bash
	node --version
	```
	
3. Если Node не установлен или ниже **14 версии**, то нужно установить его (подробности на [официальном сайте](https://nodejs.org/en/)) или обновить до последней версии (через nvm или npm).

5. Проверить установлен ли менеджер пакетов Yarn.
	```bash
	yarn --version
	```
	
6. Если Yarn не установлен, то скачать и установить.
	```bash
	npm install -g yarn
	```

##### Rust и Rust toolchain

1.  Скачать и запустить [rustup](https://rustup.rs/) - установщик Rust.
	```bash
	curl https://sh.rustup.rs -sSf |  sh
	```
	
2. Добавить директорию с бинарниками Rust в PATH.
	```bash
	source ~/.cargo/env
	```
	
3. Указать stable сборку основной версией Rust toolchain.
	```bash
	rustup default stable
	rustup update
	```
	
4. Добавить nightly сборку Rust toolchain и WebAssembly в качестве цели (платформы) для компиляции.
	```bash
	rustup update nightly
	rustup target add wasm32-unknown-unknown --toolchain nightly
	```
	
5. Убедиться, что установка прошла успешно (должна быть актуальная версия компилятора и тулчейна).
	```bash
	rustc --version
	rustup show
	```

##### Шаблон для Substrate узла

1. Склонировать [репозиторий](https://github.com/substrate-developer-hub/substrate-node-template) с шаблоном Substrate узла.
	```bash
	git clone https://github.com/substrate-developer-hub/substrate-node-template
	```
	
2. Перейти в директорию с шаблоном и переключиться на ветку latest.
	```bash
	cd substrate-node-template
	git checkout latest
	```

3. Скомпилировать шаблон узла (может занять много времени).
	```bash
	cargo build --release
	```

##### Шаблон для фронтенда

1. Склонировать [репозиторий](https://github.com/substrate-developer-hub/substrate-front-end-template) с шаблоном Substrate фронтенда.
	```bash
	git clone https://github.com/substrate-developer-hub/substrate-front-end-template
	```
	
2. Перейти в директорию с шаблоном и переключиться на ветку latest.
	```bash
	cd substrate-front-end-template
	git checkout latest
	```
	
3. Скачать и установить зависимости.
	```bash
	yarn install
	```

##### Настройка браузера

Для работы с децентрализованными приложениями с использованием собственных аккаунтов понадобится использовать **криптокошелек** ([Polkadot{.js}](https://polkadot.js.org/), [MetaMask](https://metamask.io/) и др.).

Так как в качестве фреймворка для разработки используется Substrate, то лучше всего установить кошелек Polkadot. [Chrome](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd), [Firefox 🦊](https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension/).

#### Windows

https://docs.substrate.io/v3/getting-started/windows-users/

## Создание простого децентрализованного приложения

Для начала научимся создавать простое децентрализованное приложение. Его функционал будет заключаться в том, чтобы любой пользователь (подписанный [электронной цифровой подписью](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C)) мог положить некое сообщение на блокчейн, а все остальные (не обязательно подписанные ЭЦП) могли прочитать его по требованию. При этом пользователь, отправивший сообщение последний, не сможет заменить его новым, пока кто-то другой не отправит свое сообщение. 

Последовательность действий описана для Linux, в других ОС могут незначительно меняться команды.

1. Начнем создавать собственный паллет (модуль) на основе имеющегося шаблона. В первую очередь, уберем лишние (на текущий момент) файлы: находясь в директории с шаблоном Substrate узла,	 нужно перейти в директорию с паллетами и удалить файлы ``benchmarking.rs``, ``mock.rs``, ``tests.rs``.
	```bash
	cd pallets/template/src
	```

	```bash
	$ pwd
		# должно быть ${SOME_DIR}/substrate-node-template/pallets/template/src
		# где SOME_DIR - директория, в которой хранится репозиторий
	```

	```bash
	$ tree
	.			.
	└── lib.rs

	0 directories, 1 file
	```

2. Удалим содержимое файла ``pallets/template/src/lib.rs`` и заменим следующим кодом:
	```rust
	#![cfg_attr(not(feature = "std"), no_std)]

	pub use pallet::*;

	#[frame_support::pallet]
	pub mod pallet {
	    use frame_support::pallet_prelude::*;
	    use frame_system::pallet_prelude::*;

	    // Основная структура, в которой будет содержаться логика
	    #[pallet::pallet]
	    #[pallet::generate_store(pub (super) trait Store)]
	    pub struct Pallet<T>(_);

	    /* Тут можно описывать кастомные типы, константы и прочее. */

	    // Todo: 3. Описать конфигурацию
	    #[pallet::config]
	    pub trait Config: frame_system::Config {
	        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
	    }

	    // Todo: 4. Описать генерируемые события
	    #[pallet::event]
	    #[pallet::generate_deposit(pub (super) fn deposit_event)]
	    pub enum Event<T: Config> {}

	    // Todo: 5. Описать возможные ошибки
	    #[pallet::error]
	    pub enum Error<T> {}

	    // Todo: 6. Создать Storage для хранения сообщения

	    // Todo: 7. Создать вызываемые функции для взаимодействия с блокчейном
	    #[pallet::call]
	    impl<T: Config> Pallet<T> {}
	}
	```
	
3. Опишем конфигурацию. В конфиге содержатся различные дженерики, которые можно настраивать для рантайма. ``#[pallet::config]`` - [макрос](https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#config-trait-palletconfig-mandatory), используемый при указании конфигурации, ``#[pallet::constant]`` - [макрос](https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#config-trait-palletconfig-mandatory), используемый для того, чтобы сторонние приложения (или пользователь) могли получить прямой доступ к чтению константы.
	```rust
	#[pallet::config]
    pub trait Config: frame_system::Config {
        /// Определяем тип событий.
        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
        /// Определяем максимальный размер строки сообщения (указывать будем в рантайме).
        // u32 - тип размера, Get - трейт, которому должен удовлетворять тип, передаваемый через рантайм (для данного трейта - наличие функции get)
        #[pallet::constant]
        type MaxMessageLength: Get<u32>;
    }
	```

4. Опишем набор событий, которые может генерировать наш паллет. В данном случае у нас всего одно событие: создание нового сообщения. ``#[pallet::event]`` - [документация](https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#macro-expansion-1).
	```rust
    #[pallet::event]
    #[pallet::generate_deposit(pub (super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Событие будет сгенерировано после того, как кто-то создаст новое сообщение.
        // T::AccountID - уникальный идентификатор аккаунта, тип передается через рантайм
        // BoundedVec - тип, предоставляемый FRAME, вектор с указанием максимального размера
        MessageCreated(T::AccountId, BoundedVec<u8, T::MaxMessageLength>),
    }
	```

5.  Также опишем набор ошибок, которые могут произойти во время выполнения функций паллета. Так как в задании мы описали ограничение, не дающее одному и тому же пользователю отправить два сообщения подряд, то укажем соответствующую ошибку. ``#[pallet::error]`` - [документация](https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#error-palleterror-optional). Комментарии, написанные через ``///`` автоматически воспринимаются как документация, для ошибок этот комментарий будет отправлен в качестве описания. 
	```rust
    #[pallet::error]
    pub enum Error<T> {
        /// Одному и тому же пользователю нельзя отправить сообщение дважды подряд.
        MessageFromSameUser,
    }
	```

6. Создадим Storage, в котором будет храниться наше сообщение. Используем [**StorageValue**](https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageValue.html), хранящий единственное значение. В качестве значения используем [tuple](https://doc.rust-lang.org/rust-by-example/primitives/tuples.html), хранящий [**Option**](https://doc.rust-lang.org/rust-by-example/std/option.html) с идентификатором пользователя (Option предоставляет собой [перечисление](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html), которое может быть None или Some(значение), делается это потому, что при запуске блокчейна в single value storage должно храниться значение, удовлетворяющее трейту ``Default``. В данном случае можно либо воспользоваться Option, либо имплементировать соответствующий метод для дженерик типа AccountId (его мы получаем из рантайма), либо указать правило для [genesis](https://docs.substrate.io/how-to-guides/v3/basics/genesis/) блока) и само сообщение. В качестве типа для вектора используем ``u8``, что позволит использовать en ascii символы в сообщении (для поддержки utf-8 можно использовать ``sp_std::vec::Vec<u8>`` - [низкоуровневый вектор](https://docs.rs/sp-std/2.0.0-alpha.7/sp_std/vec/struct.Vec.html), который воспринимается как строка в Substrate, но в таком случае придется вручную контролировать его длину).
	```rust
	#[pallet::storage]
    /// Хранит tuple из идентификатора пользователя и его сообщения.
    pub(super) type Message<T: Config> = StorageValue<
        _,
        (Option<T::AccountId>, BoundedVec<u8, T::MaxMessageLength>),
        ValueQuery,
    >;

	```
	
7. Создадим функцию, которая будет складывать наше сообщение на блокчейн. Про оператор ``?`` можно почитать [здесь](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator). Про ключевое слово ``match`` (частично по функционалу похожее на switch case в других языках) можно почитать [тут](https://doc.rust-lang.org/book/ch06-02-match.html). **Вес** (weight) отражает вычислительную сложность функции и, помимо всего прочего, используется при расчете стоимости транзакции ([подробнее](https://docs.substrate.io/v3/concepts/weight/). 
	```rust
	#[pallet::call]
    impl<T: Config> Pallet<T> {
        #[pallet::weight(1_000)]
        pub fn create_message(
            origin: OriginFor<T>,
            message: BoundedVec<u8, T::MaxMessageLength>,
        ) -> DispatchResult {
            // Проверяет подпись и возвращает идентификатор пользователя
            // Вернет ошибку, если транзакция не подписана
            // https://docs.substrate.io/v3/runtime/origins
            let sender = ensure_signed(origin)?;

            // Смотрим кто отправил сообщение
            let (user, _) = Message::<T>::get();
            match user {
                // Если id совпадают, то выбрасываем ошибку
                Some(user) => ensure!(sender != user, Error::<T>::MessageFromSameUser),
                _ => (),
            }

            // Сохраняем новое сообщение и пользователя (оборачивается в Some, т.к. используем Option)
            Message::<T>::put((Some(&sender), &message));

            // Отправляем событие
            Self::deposit_event(Event::MessageCreated(sender, message));

            // Expression - возвращаем положительный результат
            Ok(())
        }
    }
	```

8. Наконец, настроим максимальную длину строки через рантайм. Для этого укажем его в конфиге паллета в рантайме. В файле ``substrate-node-template/runtime/src/lib.rs`` найдем следующий кусок кода:
	```rust
	/// Configure the pallet-template in pallets/template.
	impl pallet_template::Config for Runtime {
	    type Event = Event;
	}
	```

	И изменим его:
	```rust
	/// Configure the pallet-template in pallets/template.
	impl pallet_template::Config for Runtime {
	    type Event = Event;
	    // Устанавливаем максимальный размер строки - 128
		type MaxMessageLength = frame_support::traits::ConstU32<128>;
	}
	```

9. Проверим **может** ли скомпилироваться код.
	```bash
	cargo check -p node-template-runtime
	``` 

10. Затем скомпилируем узел.
	```bash
	cargo build --release
	```

11. Запустим узел в режиме разработчика (состояние блокчейна не будет сохранено).
	```bash
	./target/release/node-template --dev
	``` 

12. Изначальный шаблон уже содержит набор различных паллетов, отвечающих за currency, управление балансом, [консенсусом](https://docs.substrate.io/v3/advanced/consensus/) (Aura + GRANDPA) и прочее. Паллеты можно отключать и подключать новые, настраивать, конфигурировать в зависимости от целей. После запуска узел должен сразу начать генерировать и валидировать новые блоки.

13. В качестве фронтенда для получившегося DApp можно использовать нативный [онлайн-фронтенд](https://polkadot.js.org/apps). При подключении к нему нужно выбрать запущенный локально узел и переключиться на него. Дальнейшее управление идет непосредственно в приложении (вызов функций, запросов, проверка состояния, исследование блоков и т.п.). Также можно написать собственный фронтенд. [Polkadot](https://polkadot.network/) (блокчейн-платформа, тесно интегрированная и использующая фреймворк Substrate), предоставляет собственное API с поддержкой удаленных вызовов функций в децентрализованном приложении. Используя скачанный ранее шаблон, можно написать кастомный фронтенд с использованием React. 
Для этого надо перейти в директорию с шаблоном фронтенда и заменить содержимое файла ``src/substrate-lib/TemplateModule.js`` следующим кодом:

	```js
	import React, {useEffect, useState} from 'react'
    import {Form, Input, Grid, Message} from 'semantic-ui-react'
    
    // Pre-built Substrate front-end utilities for connecting to a node
    // and making a transaction.
    import {useSubstrateState} from './substrate-lib'
    import {TxButton} from './substrate-lib/components'
    
    // Main component
    function Main(props) {
        // Establish an API to talk to the Substrate node.
        const {api, currentAccount} = useSubstrateState()
        // React hooks for all the state variables we track.
        // Learn more at: https://reactjs.org/docs/hooks-intro.html
        const [status, setStatus] = useState('')
        const [message, setMessage] = useState('')
        const [owner, setOwner] = useState('')
        const [currentMessage, setCurrentMessage] = useState('')
    
        // React hook, который смотрит на сообщение
        useEffect(() => {
            let unsubscribe;
            // Polkadot-JS API query to the `proofs` storage item in our pallet.
            // This is a subscription, so it will always get the latest value,
            // even if it changes.
    
            // Делаем запрос к Storage нашего паллета
            // Т.к. мы подписались на событие, то всегда будем получать самое актуальное значение
            api.query.templateModule
                .message(result => {
                    if (result.inspect().inner) {
                        let [tmpAddress, tmpBlock] = result.toHuman()
                        setOwner(tmpAddress)
                        setCurrentMessage(tmpBlock)
                    } else {
                        setOwner('')
                        setCurrentMessage('')
                    }
                })
                .then(unsub => {
                    unsubscribe = unsub;
                });
            return () => unsubscribe && unsubscribe();
            // Хук обновляется, если появляется новое сообщение в Storage
        }, [api.query.templateModule])
    
        function canSendMessage() {
            return owner !== '';
        }
    
        // The actual UI elements which are returned from our component.
        return (
            <Grid.Column>
                <h1>Отправить сообщение</h1>
                {/* Не дает отправить сообщение, если оно уже было отправлено этим пользователем. */}
                <Form success={!!message && (currentAccount ? owner !== currentAccount.address : canSendMessage())}
                      warning={(currentAccount ? owner === currentAccount.address : !canSendMessage())}>
                    <Form.Field>
                        {/* Текущее сообщение. */}
                        <Message
                            header="Текущее сообщение"
                            list={[`Отправитель: ${owner ? owner : "Нет сообщений"}`, `Сообщение: ${currentMessage}`]}
                        />
                        {/* Полее для ввода сообщения. */}
                        <Input
                            type="text"
                            id="msg"
                            label="Сообщение"
                            onChange={e => setMessage(e.target.value)}
                        />
                        {/* Если можно отправить. */}
                        <Message success header="Можно отправить сообщение" content={message}/>
                        {/* Если нельзя. */}
                        <Message
                            warning
                            header="Сообщение уже было отправлено этим пользователем"
                            list={[message, `Отправитель: ${owner}`, `Сообщение: ${currentMessage}`]}
                        />
                    </Form.Field>
                    {/* Кнопка отправки сообщения. */}
                    <Form.Field>
                        {/* Непосредственно кнопка, неактивна если нельзя отправить сообщение. */}
                        <TxButton
                            label="Отправить"
                            type="SIGNED-TX"
                            setStatus={setStatus}
                            disabled={!canSendMessage() || owner === currentAccount.address}
                            attrs={{
                                palletRpc: 'templateModule',
                                callable: 'createMessage',
                                inputParams: [message],
                                paramFields: [true]
                            }}
                        />
                    </Form.Field>
                    {/* Статус сообщения. */}
                    <div style={{overflowWrap: 'break-word'}}>{status}</div>
                </Form>
            </Grid.Column>
        );
    }
    
    export default function TemplateModule(props) {
        const {api} = useSubstrateState()
        return api.query.templateModule ? <Main {...props} /> : null
    }
	```
	
14. Устанавливаем зависимости и запускаем фронтенд-сервер. Доступ можно получить через браузер (по умолчанию http://localhost:8000/substrate-front-end-template)
	```bash
	yarn
	yarn start
	```

15. Можно поэкспериментировать с отправкой сообщений, выбирая различные аккаунты (существует набор общеизвестных аккаунтов, наиболее известные из которых Алиса и Боб, с давних времен использующиеся в качестве экземплификанта в криптографии, и используемые в целях тестирования при  разработке).

## Развертывание собственной блокчейн сети

Будем использовать написанное выше приложение, чтобы развернуть его в локальной блокчейн сети, состоящей из двух узлов.

Наше приложение использует **Proof of Authority** для достижения консенсуса. Эта модель полагается на множество предопределенных аккаунтов, которые занимаются валидацией блоков. [**Aura**](https://docs.substrate.io/rustdocs/latest/sc_consensus_aura/index.html) генерируют блоки по-очереди, равномерно распределяя нагрузку. [**GRANDPA**](https://docs.substrate.io/rustdocs/latest/sc_finality_grandpa/index.html) утверждают блоки путем "голосования" за "лучший" с их точки зрения блок. Для утверждения блока требуется не менее 2/3 голосов. Это значит, что сеть не будет нормально функционировать, пока не будет запущено как минимум 66% узлов, содержащих ключи аккаунтов GRANDPA. Для сети с двумя GRANDPA - это два минимум соответствующих узла.

Перед запуском новой сети следует **всегда** очищать данные старого блокчейна. Делается это следующим образом (из директории с приложением):
```bash
./target/release/node-template purge-chain --base-path путь-к-директории-с-данными-блокчейна --chain путь-к-спецификации-блокчейна/предопределенный-блокчейн
```

### Генерация ключей

Для запуска новой сети приватной сети (без предопределенных аккаунтов, таких как Alice и Bob) требуется сперва сгенерировать наборы [ключей](https://docs.substrate.io/v3/advanced/cryptography/#public-key-cryptography) для аккаунтов, которые будут использоваться для генерации и валидации блоков. Сделать это можно различными способами (сгенерировать вручную, через криптокошельки, специальные приложения и т.д.). Тут будет описан способ создания ключей через команду ``key`` для имеющегося шаблона узла (на основе которого был сделан DApp).

> В целях безопасности следует генерировать ключи на [машине](https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%B7%D0%B4%D1%83%D1%88%D0%BD%D1%8B%D0%B9_%D0%B7%D0%B0%D0%B7%D0%BE%D1%80_(%D1%81%D0%B5%D1%82%D0%B8_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)) которая, в идеале, никогда не подключалась к внешней сети. Как минимум стоит отключать интернет-соединение при создании ключей, которые планируется использовать на "реальных" блокчейнах. В рамках этой лабораторной работы можно генерировать ключи при активном подключении к сети, но не стоит использовать их нигде кроме данного DApp.

1. Сперва сгенерируем секретную фразу и ключи (из директории с репозиторием). Надо ввести и запомнить пароль,а также сохранить все сгенерированные даные. Они будут использоваться для Aura.
	```bash
	./target/release/node-template key generate --scheme Sr25519 --password-interactive
	```
	```bash
	# пример вывода
	Secret phrase:  pig giraffe ceiling enter weird liar orange decline behind total despair fly
	Secret seed:       0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f
	Public key (hex):  0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
	Account ID:        0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
	Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW
	SS58 Address:      5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW
	```

2. Сгенерируем и сохраним ключи для GRANDPA, **унаследовав** секретную фразу, полученную на предыдущем шаге (в примере подается фраза, сгенерированная на прошлом шаге). 
	```bash
	./target/release/node-template key inspect --password-interactive --scheme Ed25519 "pig giraffe ceiling enter weird liar orange decline behind total despair fly"
	```
	```bash
	# пример вывода
	Secret phrase `pig giraffe ceiling enter weird liar orange decline behind total despair fly` is account:
	Secret seed:       0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f
	Public key (hex):  0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b
	Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN
	Account ID:        0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b
	SS58 Address:      5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN
	```
	
3. Повторим два предыдущих шага. В итоге должны получить четыре набора ключей: два уникальных для Aura и два унаследованных для GRANDPA.

### Запуск первого узла

Для запуска сети требуется наличие спецификации. Это может быть как заранее определенная спецификация (``local`` и др.), так и сконфигурированная вручную.

При создании новой спецификации можно использовать уже предопределенные.

1. Экспортируем спецификацию ``local`` в файл ``customSpec.json``.
	```bash
	./target/release/node-template build-spec --disable-default-bootnode --chain local  > customSpec.json
	```
2. В получившемся файле, помимо прочих данных, также содержится весь Wasm бинарник для рантайма. В файле необходимо поменять следующие поля

	- Имя спецификации:
	```bash
	# пример
	"name":  "Custom Blockchain Network",
	```
	- Поле ``aura``. Сюда вместо ключей Алисы и Боба следует добавить Sr25519 SS58 ключи, сгенерированные ранее (SS58 Address).
	- Поле ``grandpa``. Вместо ключей Алисы и Боба добавляем соответствующие Ed25519 SS58 ключи (SS58 Address). В отличии от ``aura``, здесь для ``authorities`` стоит два значение. Второе указывает на вес голоса конкретного аккаунта.

3. После добавление валидаторов (каждый из которых должен иметь уникальный ключ), нужно сохранить файл и сконвертировать получившуюся спецификацию в raw формат, который будет подан на вход узлу.
	```bash
	./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode > customSpecRaw.json
	```
	
4. Затем запустим первый узел блокчейн-сети.
	```bash
	./target/release/node-template \
	--base-path /tmp/node01 \
	--chain ./customSpecRaw.json \
	--port 30333 \
	--ws-port 9945 \
	--rpc-port 9933 \
	--telemetry-url "wss://telemetry.polkadot.io/submit/ 0" \
	--validator \
	--rpc-methods Unsafe \
	--name MyNode01
	```

> При запуске узлов в контейнере, нужно будет добавить флаги ``--unsafe-ws-external`` и ``--unsafe-rpc-external``, чтобы к узлам можно было обратиться извне контейнера.

5. В команде, вызываемой выше:
	- ``--base-path`` - указывает где будут сохраняться данные блокчейна для этого узла;
	- ``--chain`` - указывает путь к спецификации блокчейна;
		- ``--port`` - порт для общения с другими узлами по p2p-сети;
	- ``--ws-port`` - порт для входящего WebSocket траффика (по дефолту 9944);
	- ``--rpc-port`` - порт для использования RPC (remote procedure call);
	- ``--telemetry-url`` - куда будет отправляться различная телеметрия (для учебных целей можно использовать указанную выше ссылку и посмотреть там данные по сети в реальном времени);
	- ``--validator`` - указывает, что этот узел участвует в генерации и утверждении новых блоков;
	- ``--name`` - имя узла

6. После запуска нужно запомнить значение **Local node identity**, которое будет использоваться при подключении последующих узлов.

### Добавление ключей в keystore

Несмотря на то, что сеть уже запущена, никаких новых блоков не генерируется. Для того, чтобы сеть работала корректно, необходимо для каждого узла добавить ключи Aura и GRANDPA.

Как и при генерации ключей, здесь есть несколько вариантов (через RPC, curl и др.), но описан будет способ добавления через команду ``key`` для шаблона узла.

1. Добавим Aura ключ для первого узла. В качестве параметра для флага ``--suri`` подается поле ``Secret seed`` из сгенерированного Sr25519 ключа.
	```bash
	./target/release/node-template key insert --base-path /tmp/node01 \
	--chain customSpecRaw.json \
	--scheme Sr25519 \
	--suri секретный-сид \
	--password-interactive \
	--key-type aura
	```
	
2. Добавим GRANDPA ключ для первого узла. В качестве параметра для флага ``--suri`` подается поле ``Secret seed`` из сгенерированного Ed25519 ключа **соответствующего аккаунта** (который унаследован от аккаунта, использованного в первом шаге).
	```bash
	./target/release/node-template key insert --base-path /tmp/node01 \
	--chain customSpecRaw.json \
	--scheme Ed25519 \
	--suri секретный-сид \
	--password-interactive \
	--key-type gran
	```
	
3. В качестве пароля на предыдущих шагах, используем пароль, введенный при генерации ключей.

4. Убедимся, что ключи были успешно добавлены (должно быть два значения).
	```bash
	ls /tmp/node01/chains/local_testnet/keystore
	```

### Запуск второго (и последующих) узлов с добавлением новых ключей в keystore соответствующих узлов

1. Запускаем второй узел.
	```bash
	./target/release/node-template \
	--base-path /tmp/node02 \
	--chain ./customSpecRaw.json \
	--port 30334 \
	--ws-port 9946 \
	--rpc-port 9934 \
	--telemetry-url "wss://telemetry.polkadot.io/submit/ 0" \
	--validator \
	--rpc-methods Unsafe \
	--name MyNode02 \
	--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/здесь-указывается-local-node-indentity \
	--password-interactive
	```

2. Для данной сети единственным **bootnode** является первый узел. В соответствии с названием, подобная нода является стартовой. Одним из его назначений является обнаружение других узлов и передача данных о них другим нодам в сети.

3. Добавим Aura и GRANDPA ключи в keystore для второго узла, используя вторую пару соответствующих ключей.
	```bash
	./target/release/node-template key insert --base-path /tmp/node02 \
	--chain customSpecRaw.json \
	--scheme Sr25519 \
	--suri секретный-сид-второго-аккаунта \
	--password-interactive \
	--key-type aura
	```

	```bash
	./target/release/node-template key insert --base-path /tmp/node02 \
	--chain customSpecRaw.json \
	--scheme Ed25519 \
	--suri секретный-сид-второго-аккаунта \
	--password-interactive \
	--key-type gran
	```

4. Узел, в keystore которого добавляется GRANDPA ключ, требуется перезапустить.

5. После того, как узлы были перезапущены и в сети активно 66% и более узлов с аккаунтами GRANDPA, блоки начнут добавляться в блокчейн.

6. Наиболее подробно состояние сети можно посмотреть тут: https://polkadot.js.org/apps. Надо указать адрес сервера и порт с которым по вебсокету будет соединяться веб-приложение.

## Задание

Создать децентрализованное приложение, реализующее концепцию **PoE** (Proof of Existance, доказательство существования) и позволяющее пользователям "владеть" объектами, представленными в виде файла, и "продавать" их за сумму, определяемую владельцем.

- Пользователь должен владеть самим содержимым файла, а не его названием (и другими метаданными).
- Само содержимое файла не должно храниться на блокчейне, вместо этого необходимо считать его хеш.
- Потенциальные коллизии допустимы в рамках задания и от них можно не избавляться.
- Для получения "права владения" файлом пользователю достаточно просто указать файл и желаемую цену для выкупа.
- Обычный пользователь не должен иметь возможности завладеть чужим файлом, но он может купить его за **полную** указанную стоимость.
- Владелец при этом не должен иметь возможности купить файл сам у себя.
- Нужно реализовать полностью готовое приложение (включая фронтенд).
- Хеширование файла должно происходить на стороне фронтенда.
- Нужно локально поднять собственную сеть как минимум из **трех** узлов, которая сохранит данные даже при отключении всех узлов.
- Все операции (кроме SUDO) должны проводиться с использованием собственных уникальных аккаунтов (не Alice, не Bob, не Charlie и т.д.).

### Советы

- Для операций, связанных с переводом некоей валюты, пригодится макрос [``#[transactional]``](https://docs.substrate.io/rustdocs/latest/frame_support/attr.transactional.html). Подключить его можно указав в начале описания модуля паллета:
	```rust
	pub  mod  pallet  {
	    use frame_support::{
            transactional
        };

	    ...
	```

- В качестве Storage стоит использовать [StorageMap](https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageMap.html), где ключ - хеш файла, представленного в виде вектора байтов (``u8``), а значение - tuple, содержащий [AccountId](https://docs.substrate.io/rustdocs/latest/sp_runtime/traits/trait.IdentifyAccount.html) (в изменяемом паллете представлен в виде дженерика, сам тип передается из рантайма на основе соответствующего [паллета](https://docs.substrate.io/rustdocs/latest/pallet_balances/index.html)) и цену за выкуп.

- Для возможности осуществлять обмен валюты между пользователями, стоит использовать типы, удовлетворяющие трейту [``Currency``](https://docs.substrate.io/rustdocs/latest/frame_support/traits/tokens/currency/trait.Currency.html). Существует паллет Balances, имплементирующий данный трейт. Для его использования следует сделать следующее:
	1. Передать в паллет через **рантайм конфиг** тип Currency из паллета Balances.
	```rust
	impl *название паллета*::Config  for  Runtime  {
	    ...
	    type Currency = Balances;
	    ...
	}
	```
	2. Объявить использование трейта ``Currency`` в самом паллете.
	```rust
	pub mod pallet {
	    ...
	    use frame_support::{
	        ...
	        traits::{..., Currency, ...},
	        ...
	    };
	...
	```
	3. В конфиге паллета указать используемый тип Currency, удовлетворяющий трейту ``Currency``.
	```rust
	#[pallet::config]
	pub trait Config: frame_system::Config {
	...
	    type Currency: Currency<Self::AccountId>;
	...
	}
	```
	4. Конкретные значения баланса через обозначенный тип можно получить, используя следующую конструкцию. Подробнее про нее можно почитать [тут](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types).
	```rust
	<<T  as  Config>::Currency  as  Currency<<T  as  frame_system::Config>::AccountId>>::Balance
	```
	Описанный выше тип можно хранить в Storage, пробрасывать в ивенты и ошибки и передавать в качестве аргументов функций, проводить операции сравнения и т.п.
	5. Вместо того, чтобы каждый раз писать вышеуказанное, можно определить отдельный тип и использовать его. 
	```rust
	type BalanceValue<T> = <<T as Config>::Currency  as Currency<<T as frame_system::Config>::AccountId>>::Balance;
	```

- Для обработки файлов на фронтенде можно использовать следующее:
	```js
	...
	
	//Для хеширования файлов
	import  {blake2AsHex}  from  '@polkadot/util-crypto'

	function  Main(props)  {
	    ...
	    // Еще один React хук 
	    const  [digest, setDigest]  =  useState('')
	    ...
	    let fileReader;
	    // Делает хеш на основе содержимого файла в шестнадцатиричном виде (256 бит - 64 hex разряда)
	    const bufferToDigest = () => {
	        const content = Array.from(new Uint8Array(fileReader.result))
	          .map(b => b.toString(16).padStart(2, '0'))
	          .join('');
	        const hash = blake2AsHex(content, 256);
	        setDigest(hash);
	    };
	    
	   
	    // Коллбэк при загрузке файла
	    const handleFileChosen = file => {
	        fileReader = new FileReader();
	        fileReader.onloadend = bufferToDigest;
	        fileReader.readAsArrayBuffer(file);

	    // Фронтенд должен проверять текущее состояние хранилища не только при его апдейте, но и при попытке загрузить (не отправить!) новый файл. 
	    useEffect(()  =>  {
	        ...
	    }, [[digest, api.query.название_паллета])
	    
	    ...
  };
	```

- Для проведения операций с получившимся DApp следует использовать криптокошельки с хранящимися на них данными об аккаунтах.

В общем целом выполнение задание сводится к следующему:

 - [ ] Продумать типы и ограничения
 - [ ] Настроить конфиг паллета
 - [ ] Описать генерируемые ивенты
 - [ ] Описать возможные ошибки
 - [ ] Продумать формат Storage (их может быть несколько)
 - [ ] Написать функцию получения владения файлом
 - [ ] Написать функцию покупки файла
 - [ ] Написать фронтенд на основе шаблона (используя куски кода, которые были даны выше)
 - [ ] Поднять блокчейн-сеть
 - [ ] Поднять фронтенд-сервер

## Полезные ссылки

- Официальный сайт Substrate - https://substrate.io/
- Туториалы для Substrate - https://docs.substrate.io/tutorials/v3/
- Документация для Substrate - https://paritytech.github.io/substrate/master/sc_service/index.html
- Официальный сайт платформы Polkadot - https://polkadot.network/
- Веб-приложение Polkadot - https://polkadot.js.org/
- libp2p - https://libp2p.io/
- Metamask - https://metamask.io/
- Документация Rust - https://doc.rust-lang.org/std/
- Учебник Rust - https://doc.rust-lang.org/book/
- Rust playground - https://play.rust-lang.org/
- Документация по докеру - https://docs.docker.com/
- Паттерны блокчейн разработки - https://research.csiro.au/blockchainpatterns/
- Немножко о DAG - https://cointelegraph.com/explained/what-is-a-directed-acyclic-graph-in-cryptocurrency-how-does-dag-work#:~:text=A%20directed%20acyclic%20graph%20or,on%20top%20of%20one%20another.
- IPFS, межпланетная файловая система - https://ipfs.io/
- Merkle proof - https://tsc.bitcoinassociation.net/standards/merkle-proof-standardised-format/
- Смарт-контракты в сети Ethereum - https://www.loginradius.com/blog/engineering/guest-post/ethereum-smart-contract-tutorial/
- Игра-туториал по Solidity - https://cryptozombies.io/
- Вебассемблер - https://webassembly.org/
- Cosmos, фреймворк для написания блокчейн-приложений на Go - https://tutorials.cosmos.network/
- Truffle, фреймворк для написания смарт-контрактов на Solidity для Ethereum https://trufflesuite.com/
- https://hardhat.org/
- https://www.alchemy.com/
